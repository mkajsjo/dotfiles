extends twapi

global !p
import re

def expand_snippet_multiline_list(start, stop, snip):
	n = int(snip.buffer[snip.line].strip())

	# erase current line
	snip.buffer[snip.line] = re.sub(
		r"\w*",
		"",
		snip.buffer[snip.line]
	)

	snippet_body = start
	for i in range(1, n + 1):
		snippet_body += '\t${' + str(i) + ':' + str(chr(64 + i)) + '},\n'

	snippet_body = snippet_body[:-2] + '\n'
	snippet_body += stop + '${' + str(n + 1) + '}'

	snip.expand_anon(snippet_body)

def expand_function_clause(snip):
	matches = re.match(
		r'^(\w*)\((.*)\) ->\s*',
		snip.buffer[snip.line]
	)

	snip.buffer[snip.line] = ''

	tabstops = '${1}'
	n = 2
	param_string = matches.group(2)

	if len(param_string) > 0:
		params = matches.group(2).split(', ')
		tabstops = ''
		for i, p in enumerate(params):
			tabstops += '${' + str(i + 1) + ':' + p + '}, '
			n = i + 2

		tabstops = tabstops[:-2]


	snippet_body = matches.group(1) \
				 + '(' + tabstops \
				 + ') ->\n' \
				 + '\t${' + str(n) + ':Body}\n' \
				 + matches.group(0)

	snip.expand_anon(snippet_body)
endglobal


post_jump "expand_function_clause(snip)"
snippet /^\w+\(.*\) ->\s*/ "" r
`!p snip.rv = match.group(0)`
endsnippet


post_jump "expand_snippet_multiline_list('\{\n', '}', snip)"
snippet /\{(\d)/ "" r
`!p snip.rv = match.group(1)`
endsnippet


post_jump "expand_snippet_multiline_list('[\n', ']', snip)"
snippet /\[(\d)/ "" r
`!p snip.rv = match.group(1)`
endsnippet


post_jump "expand_snippet_multiline_list('#\{\n', '}', snip)"
snippet /\#(\d)/ "" r
`!p snip.rv = match.group(1)`
endsnippet


post_jump "expand_snippet_multiline_list('<<\n', '>>', snip)"
snippet /\<(\d)/ "" r
`!p snip.rv = match.group(1)`
endsnippet


snippet [
[
	${1}
]
endsnippet


snippet {
{
	${1}
}
endsnippet


snippet #
#{
	${1}
}
endsnippet


snippet <
<<
	${1}
>>
endsnippet


snippet |
[
	${3:$2}
||
	${2:N} <- ${1:List}
]
endsnippet


snippet map
lists:map(
	fun (${2:N}) ->
			${3:$2}
	end,
	${1:List}
)
endsnippet


snippet fold
lists:foldl(
	fun (${3:N}, ${4:Acc}) ->
			${5:$4}
	end,
	${2:#{}},
	${1:List}
)
endsnippet


snippet foldr
lists:foldr(
	fun (${3:N}, ${4:Acc}) ->
			${5:$4}
	end,
	${2:#{}},
	${1:List}
)
endsnippet


snippet case
case ${1:Expr} of
	${2:true} ->
		${3:ok};
	${4:false} ->
		${5:ok}
end
endsnippet


snippet try
try
	${1:Expr}
catch
	${2:_:_} ->
		${3:throw(todo)}
end
endsnippet


snippet fun
fun (${1:Args}) ->
		${2:Body}
end
endsnippet


snippet /-?module/ "" r
-module(`!p fn.split('.')[0]`).

-export(
	[

	]
).

${1}
endsnippet


snippet /-?record/ "" r
-record(
	${1:Name},
	{
		${2:Fields}
	}
).
endsnippet


snippet a2b
atom_to_binary(${1:Atom})
endsnippet


snippet b2a
binary_to_existing_atom(${1:Binary}, utf8)
endsnippet


snippet i2b
integer_to_binary(${1:Int})
endsnippet


snippet f2b
float_to_binary(${1:Float}, [\{decimals, ${2:D}}, compact])
endsnippet


snippet l2b
list_to_binary(${1:List})
endsnippet


snippet b2l
binary_to_list(${1:Binary})
endsnippet


snippet io2b
iolist_to_binary(${1:IoList})
endsnippet


snippet m2l
maps:to_list(${1:Map})
endsnippet


snippet l2m
maps:to_list(${1:Map})
endsnippet


snippet io
io:fwrite("$1: ~p~n", [${1}])
endsnippet


# maps
snippet mfilter
maps:filter(
	fun (${2:K}, ${3:V}) ->
			${4:true}
	end,
	${1:Map}
)
endsnippet


snippet mfind
maps:find(${1:Key}, ${2:Map})
endsnippet


snippet mfold
maps:foldl(
	fun (${3:K}, ${4:V}, ${5:Acc}) ->
			${6:$5}
	end,
	${2:#{}},
	${1:Map}
)
endsnippet


snippet mfromlist
maps:from_list(${1:List})
endsnippet


snippet mget
maps:get(${1:Key}, ${2:Map}, ${3:undefined})
endsnippet


snippet mkey
maps:is_key(${1:Key}, ${2:Map})
endsnippet


snippet miter
maps:iterator(${1:Map})
endsnippet


snippet mkeys
maps:keys(${1:Map})
endsnippet


snippet mmap
maps:map(
	fun (${2:K}, ${3:V}) ->
			${4:$3}
	end,
	${1:Map}
)
endsnippet


snippet mmerge
maps:merge(${1:A}, ${2:B})
endsnippet


snippet mnext
maps:next(${1:Iterator})
endsnippet


snippet mput
maps:put(${1:Key}, ${2:Value}, ${3:Map})
endsnippet


snippet mremove
maps:remove(${1:Key}, ${2:Map})
endsnippet


snippet msize
maps:size(${1:Map})
endsnippet


snippet mtake
maps:take(${1:Key}, ${2:Map})
endsnippet


snippet mtolist
maps:to_list(${1:Map})
endsnippet


snippet mupdate
maps:put(${1:Key}, ${2:Value}, ${3:Map})
endsnippet


snippet mupdatewith
maps:update_with(
	${3:Key},
	fun (${4:V}) ->
		${5:$3}
	end,
	${2:Default},
	${1:Map}
)
endsnippet


snippet mvalues
maps:values(${1:Map})
endsnippet


snippet mwith
maps:with(${1:Keys}, ${2:Map})
endsnippet


snippet mwithout
maps:without(${1:Keys}, ${2:Map})
endsnippet
# end maps


# proplists
snippet pfilter
lists:filter(
	fun ({${2:K}, ${3:V}}) ->
			${4:true}
	end,
	${1:List}
)
endsnippet


snippet pfold
lists:foldl(
	fun ({${3:K}, ${4:V}}, ${5:Acc}) ->
			${6:$5}
	end,
	${2:#{}},
	${1:List}
)
endsnippet


snippet pget
proplists:get_value(${1:Key}, ${2:List}`!p
if t[3] == '' or t[3] == 'undefined':
	snip.rv = ''
else:
	snip.rv = ', '
`${3:Default}`!p if t[3] == 'undefined': t[3] = ''`)
endsnippet


snippet pkey
proplists:is_defined(${1:Key}, ${2:List})
endsnippet


snippet pkeys
proplists:get_keys(${1:List})
endsnippet


snippet pmap
lists:map(
	fun ({${2:K}, ${3:V}}) ->
			{$2, ${4:$3}}
	end,
	${1:List}
)
endsnippet


snippet pmerge
lists:keymerge(
	1,
	lists:keysort(1, ${2:Overrides}),
	lists:keysort(1, ${1:List})
)
endsnippet


snippet pput
[{${1:Key}, ${2:Value}} | ${3:List}]
endsnippet


snippet pupdate
lists:keyreplace(${1:Key}, 1, ${2:List}, {$1, ${3:Value}})
endsnippet


snippet premove
proplists:delete(${1:Key}, ${2:List})
endsnippet


snippet psize
length(${1:List})
endsnippet


snippet ptake
lists:keytake(${1:Key}, 1, ${2:List})
endsnippet


snippet pvalues
[${2:N} || {_, $2} <- ${1:List}]
endsnippet


snippet pwith
[
	${3:N}
||
	{K, _} = $3 <- ${1:List},
	lists:keymember(K, 1, ${2:With})
]
endsnippet


snippet pwithout
[
	${3:N}
||
	{K, _} = $3 <- ${1:List},
	not lists:keymember(K, 1, ${2:Without})
]
endsnippet
# end proplists
